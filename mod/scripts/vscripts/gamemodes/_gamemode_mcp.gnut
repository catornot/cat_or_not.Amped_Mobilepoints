untyped
global function GamemodeMCP_Init
global function RateSpawnpoints_MCP

global hardpointsReady = 0

struct NewHardpointState
{
	entity trigger
    vector origin
    vector angles
}

void function GamemodeMCP_Init()
{
    Riff_ForceTitanAvailability( eTitanAvailability.Never )

	Hardpoints_Init()

	ScoreEvent_SetupEarnMeterValuesForMixedModes()

	AddCallback_EntitiesDidLoad( EntitiesDidLoad_SpawnHardpoints )
	AddCallback_OnPlayerKilled( Hardpoints_OnPlayerKilled_UpdateMedals )

	ScoreEvent_SetEarnMeterValues("KillPilot", 0.1, 0.12)
	ScoreEvent_SetEarnMeterValues("KillTitan", 0, 0)
	ScoreEvent_SetEarnMeterValues("TitanKillTitan", 0, 0)
	ScoreEvent_SetEarnMeterValues("PilotBatteryStolen", 0, 35)
	ScoreEvent_SetEarnMeterValues("Headshot", 0, 0.02)
	ScoreEvent_SetEarnMeterValues("FirstStrike", 0, 0.05)

	ScoreEvent_SetEarnMeterValues("ControlPointCapture", 0.1, 0.1)
	ScoreEvent_SetEarnMeterValues("ControlPointHold", 0.02, 0.02)
	ScoreEvent_SetEarnMeterValues("ControlPointAmped", 0.2, 0.15)
	ScoreEvent_SetEarnMeterValues("ControlPointAmpedHold", 0.05, 0.05)

	ScoreEvent_SetEarnMeterValues("HardpointAssault", 0.10, 0.15)
	ScoreEvent_SetEarnMeterValues("HardpointDefense", 0.5, 0.10)
	ScoreEvent_SetEarnMeterValues("HardpointPerimeterDefense", 0.1, 0.12)
	ScoreEvent_SetEarnMeterValues("HardpointSiege", 0.1, 0.15)
	ScoreEvent_SetEarnMeterValues("HardpointSnipe", 0.1, 0.15)

	RegisterSignal( "StoppedHardpointMovement" )
}

void function RateSpawnpoints_MCP( int checkClass, array<entity> spawnpoints, int team, entity player )
{
	if ( HasSwitchedSides() )
		team = GetOtherTeam( team )

	// check hardpoints, determine which ones we own
	array<entity> startSpawns = SpawnPoints_GetPilotStart( team )
	vector averageFriendlySpawns

	// average out startspawn positions
	foreach ( entity spawnpoint in startSpawns )
		averageFriendlySpawns += spawnpoint.GetOrigin()

	averageFriendlySpawns /= startSpawns.len()

	entity friendlyHardpoint // determine our furthest out hardpoint
	foreach ( entity hardpoint in HARDPOINTS )
	{
		if ( hardpoint.GetTeam() == player.GetTeam() && GetGlobalNetFloat( "objective" + CapturePoint_GetGroup(hardpoint) + "Progress" ) >= 0.95 )
		{
			if ( IsValid( friendlyHardpoint ) )
			{
				if ( Distance2D( averageFriendlySpawns, hardpoint.GetOrigin() ) > Distance2D( averageFriendlySpawns, friendlyHardpoint.GetOrigin() ) )
					friendlyHardpoint = hardpoint
			}
			else
				friendlyHardpoint = hardpoint
		}
	}

	vector ratingPos
	if ( IsValid( friendlyHardpoint ) )
		ratingPos = friendlyHardpoint.GetOrigin()
	else
		ratingPos = averageFriendlySpawns

	foreach ( entity spawnpoint in spawnpoints )
	{
		// idk about magic number here really
		float rating = 1.0 - ( Distance2D( spawnpoint.GetOrigin(), ratingPos ) / 1000.0 )
		spawnpoint.CalculateRating( checkClass, player.GetTeam(), rating, rating )
	}
}

void function EntitiesDidLoad_SpawnHardpoints()
{
    #if BP_ORT && BOTEXTRAS
	if (GetConVarBool( "auto_select_gamemode") )
    	SetConVarInt( "bot_cmds_type", 8 )
    #endif

	foreach ( entity hp in GetEntArrayByClass_Expensive("info_hardpoint") )
	{
		if ( MobileHardpointRemove( hp ) || !hp.HasKey( "triggerTarget" ) )
			continue

		HardpointState hpState
		hpState.group = CapturePoint_GetGroup( hp )
		hpState.ent = hp
		hpState.prop = CreatePropDynamic( hp.GetModelName(), hp.GetOrigin(), hp.GetAngles(), SOLID_VPHYSICS )
		hpState.trigger = GetEnt( expect string(hp.kv.triggerTarget) )
		CPstate.hardpoints.append( hpState )

		switch (hpState.group) {
			case "A":
				hp.SetHardpointID( 0 )
				break
			case "B":
				hp.SetHardpointID( 1 )
				break
			case "C":
				hp.SetHardpointID( 2 )
				break
			default:
				throw "unknown hardpoint group name"
		}

		SetTeam( hpState.ent, TEAM_UNASSIGNED )
		SetGlobalNetEnt( "objective" + hpState.group + "Ent", hpState.ent )
		
		hpState.trigger.SetEnterCallback( OnHardpointEnter )
		hpState.trigger.SetLeaveCallback( OnHardpointLeave )
		hpState.trigger.SetOwner( hp )

		hpState.ent.Minimap_SetCustomState( hpState.ent.GetHardpointID() + 1 )
		hpState.ent.Minimap_AlwaysShow( TEAM_MILITIA, null )
		hpState.ent.Minimap_AlwaysShow( TEAM_IMC, null )
		hpState.ent.Minimap_SetAlignUpright( true )

		hpState.ent.s.prop <- hpState.prop
		hpState.ent.s.state <- CAPTURE_POINT_STATE_UNASSIGNED


		HARDPOINTS.append( hpState.ent ) // for vo script
		hpState.ent.s.trigger <- hpState.trigger // also for vo script

		thread PlayAnim( hpState.prop, "mh_inactive_idle" )

		thread Hardpoint_Think( hpState )
	}

	thread TrackChevronStates()
    thread HandleCapturepointMovement()
}

void function HandleCapturepointMovement()
{
	while ( GetGameState() != eGameState.Playing )
		WaitFrame()

	while ( GetGameState() <= eGameState.Playing )
	{
        wait 30

        CPstate.hardpoints.randomize()
        vector destination = CPstate.hardpoints[ CPstate.hardpoints.len() - 1 ].prop.GetOrigin()
        vector angles = CPstate.hardpoints[ CPstate.hardpoints.len() - 1 ].prop.GetAngles()
        entity trigger = CPstate.hardpoints[ CPstate.hardpoints.len() - 1 ].trigger
        foreach( HardpointState hardpoint in CPstate.hardpoints )
        {
            hardpoint.trigger.Disable()
            
            NewHardpointState newHp
        	newHp.trigger = trigger
            newHp.origin = destination
            newHp.angles = angles

            thread HandleSingleHardpointMovement( hardpoint, newHp )
            thread HandleHardpointRuiMovement( hardpoint )
            thread HandleHardpointTrigger( hardpoint, CreateTriggerRadiusMultiple( hardpoint.prop.GetOrigin(), 400., [], TRIG_FLAG_PLAYERONLY, 400., -400. ) )
            destination = hardpoint.prop.GetOrigin()
            angles = hardpoint.prop.GetAngles()
            trigger = hardpoint.trigger
        }
        
        while ( hardpointsReady < 3 )
            WaitFrame()
        
        foreach( entity player in GetPlayerArray() )
            Remote_CallFunction_Replay( player, "ServerCallback_MobileCapturepoints_Moving" )

        while ( hardpointsReady > 0 )
            WaitFrame()

        foreach( entity player in GetPlayerArray() )
            Remote_CallFunction_Replay( player, "ServerCallback_MobileCapturepoints_Settled" )
    }
}

void function HandleSingleHardpointMovement( HardpointState hp, NewHardpointState newHp )
{
    WaitFrame()

	array<vector> path = OcttreeFindPath( hp.prop.GetOrigin() + <0,0,50>, newHp.origin + <0,0,50> )

    hardpointsReady += 1

    thread HandleSingleHardpointMovementFollow( hp, newHp, path )
}

void function HandleSingleHardpointMovementFollow( HardpointState hp, NewHardpointState newHp, array<vector> path )
{
    // angle it correctly
    hp.prop.SetAngles( <0, hp.prop.GetAngles().y, 0> )
    
    entity mover = CreateScriptMover( hp.prop.GetOrigin(), hp.prop.GetAngles() )
    hp.prop.SetParent( mover )
    
    float totalTime = Distance2D( hp.prop.GetOrigin(), newHp.origin ) / 50.
    float timePerLine = totalTime / path.len()

    foreach( vector point in path )
    {
        mover.NonPhysicsMoveTo( point, 0.000001, 0.0, 0.0 )
        // wait timePerLine
        WaitFrame()
    }

    mover.NonPhysicsMoveTo( newHp.origin, timePerLine * 2, 0.0, 0.0 )
    mover.NonPhysicsRotateTo( newHp.angles, timePerLine * 4, 0.0, 0.0 )

    wait timePerLine * 4 // wait last moveto

    // clear mover
    hp.prop.ClearParent()
    mover.Destroy()

    // setup new hp
    hp.prop.SetOrigin( newHp.origin )
    hp.prop.SetAngles( newHp.angles )
    hp.ent.SetOrigin( hp.prop.GetOrigin() )

    // setup new trigger
    hp.trigger = newHp.trigger
    hp.trigger.SetOwner( hp.ent )
    hp.trigger.Enable()
    hp.trigger.SearchForNewTouchingEntity()

    hp.ent.Signal( "StoppedHardpointMovement" )

    hardpointsReady -= 1
}

void function HandleHardpointRuiMovement( HardpointState hp )
{
    hp.ent.EndSignal( "StoppedHardpointMovement" )

    for(;;)
    {
        hp.ent.SetOrigin( hp.prop.GetOrigin() )
        foreach( entity player in GetPlayerArray() )
            Remote_CallFunction_NonReplay( player, "ServerCallback_MobileCapturepoint_Moved", hp.ent.GetEncodedEHandle() )
        WaitFrame()
    }
}

void function HandleHardpointTrigger( HardpointState hp, entity trigger )
{
    hp.ent.EndSignal( "StoppedHardpointMovement" )
    trigger.SetParent( hp.prop )
    trigger.SetOwner( hp.ent )

    AddCallback_ScriptTriggerEnter( trigger, OnHardpointEnter )
    AddCallback_ScriptTriggerLeave( trigger, OnHardpointLeave )

	OnThreadEnd(
		function() : ( trigger )
		{
            foreach( entity ent in GetAllEntitiesInTrigger( trigger ) )
                OnHardpointLeave( trigger, ent )
            trigger.Destroy()
        }
	)

    hp.ent.WaitSignal( "StoppedHardpointMovement" )
}

bool function MobileHardpointRemove( entity ent )
{
    string gameMode = "cp"

	not_AT_CollisionCleanup( ent )

	string gamemodeKey = "gamemode_" + gameMode
	if ( ent.HasKey( gamemodeKey ) && (ent.kv[gamemodeKey] == "0" || ent.kv[gamemodeKey] == "") )
	{
		// printt( "Removing ent " + ent.GetClassName() + " with " + gamemodeKey + " = \"" + ent.kv[gamemodeKey] + "\" at " + ent.GetOrigin() )
		ent.Destroy()
		return true
	}
	//printt( "keeping ent", ent.GetClassName() )

	return false
}

void function not_AT_CollisionCleanup( entity spawnPoint )
{
	if ( spawnPoint.GetScriptName() == "at_mega_turret" )
	{
		if ( spawnPoint.GetLinkEnt() != null ) // assuming this is func_brush_navmesh_separator
		{
			entity brush = spawnPoint.GetLinkEnt()
			brush.NotSolid()
		}
	}
}

